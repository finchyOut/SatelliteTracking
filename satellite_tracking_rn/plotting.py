# plotting.py
# ====================
# This file provides plotting functions to visualize the orbits of a satellite using the
# pandas DataFrame log generated by the OrbitSimulator.

# ---- Imports ----
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Union
from mpl_toolkits.mplot3d import Axes3D
import constants as const

# ---- Constants ----
# Use constants from your constants.py file for consistency
EARTH_RADIUS_M = const.R_EARTH
GEO_RADIUS_M = const.GEO_RADIUS

# ---------- Helper Functions ----------
def _as_df(df_or_path: Union[str, pd.DataFrame]) -> pd.DataFrame:
    """
    Ensures we always work with a pandas DataFrame.
    """
    if isinstance(df_or_path, pd.DataFrame):
        return df_or_path
    return pd.read_csv(df_or_path)

def _set_equal_3d(ax, xs, ys, zs, pad_frac=0.08):
    """
    Ensures 3D plot has equal scaling for X, Y, Z axes so spheres look spherical.
    pad_frac: fraction of the max range to pad on each axis for spacing.
    """
    x_min, x_max = np.nanmin(xs), np.nanmax(xs)
    y_min, y_max = np.nanmin(ys), np.nanmax(ys)
    z_min, z_max = np.nanmin(zs), np.nanmax(zs)
    cx = 0.5*(x_min + x_max)
    cy = 0.5*(y_min + y_max)
    cz = 0.5*(z_min + z_max)
    r = max(x_max - x_min, y_max - y_min, z_max - z_min)
    r = max(r, 1.0) * (1 + pad_frac) * 0.5
    ax.set_xlim(cx - r, cx + r)
    ax.set_ylim(cy - r, cy + r)
    ax.set_zlim(cz - r, cz + r)

# ---------- Satellite-only plots ----------
def plot3d(log_df: pd.DataFrame, title='Satellite Orbit with Earth Centered'):
    """
    Plots only the satellite's trajectory in 3D, color-coded by stationkeeping status.
    """
    x = log_df["X (m)"].values
    y = log_df["Y (m)"].values
    z = log_df["Z (m)"].values
    status = log_df["Status"].values

    fig = plt.figure(figsize=(10, 10))
    ax = fig.add_subplot(111, projection='3d')

    # Scatter plot: stationkeeping vs non-stationkeeping
    ax.scatter(x[status == "stationkeeping"], y[status == "stationkeeping"], z[status == "stationkeeping"],
               label="Stationkeeping", s=3)
    ax.scatter(x[status == "non-stationkeeping"], y[status == "non-stationkeeping"], z[status == "non-stationkeeping"],
               label="Free-Drift", s=3, marker='x')

    # Plot Earth as a sphere
    u, v = np.mgrid[0:2*np.pi:50j, 0:np.pi:25j]
    ex = EARTH_RADIUS_M * np.cos(u) * np.sin(v)
    ey = EARTH_RADIUS_M * np.sin(u) * np.sin(v)
    ez = EARTH_RADIUS_M * np.cos(v)
    ax.plot_surface(ex, ey, ez, color='blue', alpha=0.3, linewidth=0)

    # Axis labels and title
    ax.set_xlabel("X (m)")
    ax.set_ylabel("Y (m)")
    ax.set_zlabel("Z (m)")
    ax.set_title(title)
    ax.legend()
    
    # Ensure equal aspect ratio for 3D plot
    _set_equal_3d(ax, x, y, z)
    
    plt.show()


def plot2d(log_df: pd.DataFrame, title='2D XY View of Satellite Orbit'):
    """
    Plots only the satellite's XY projection, with Earth shown as a blue circle.
    """
    x = log_df["X (m)"].values
    y = log_df["Y (m)"].values
    status = log_df["Status"].values

    fig, ax = plt.subplots(figsize=(8, 8))

    # Scatter plot for each status
    ax.scatter(x[status == "stationkeeping"], y[status == "stationkeeping"], label="Stationkeeping", s=3, marker='^')
    ax.scatter(x[status == "non-stationkeeping"], y[status == "non-stationkeeping"], label="Free-Drift", s=3, marker='x')

    # Draw Earth as a circle (top-down view)
    earth = plt.Circle((0, 0), EARTH_RADIUS_M, color='blue', alpha=0.2, label="Earth (not to scale)")
    ax.add_artist(earth)

    # Formatting
    ax.set_xlabel("X Position (m)")
    ax.set_ylabel("Y Position (m)")
    ax.set_title(title)
    ax.set_aspect('equal')
    ax.grid(True)
    ax.legend()
    plt.tight_layout()
    plt.show()


def plot_controller_performance(log_df: Union[str, pd.DataFrame], policy_params: dict):
    """
    Plots the satellite's distance from the reference trajectory and the
    magnitude of the control acceleration over time, using a DataFrame log.
    
    Args:
        log_df (Union[str, pd.DataFrame]): A DataFrame containing the simulation log
                                            or a path to a CSV file.
        policy_params (dict): A dictionary containing controller parameters,
                              specifically the deadband radius 'gamma'.
    """
    if isinstance(log_df, str):
        log_df = pd.read_csv(log_df)

    # Calculate distance from ideal position using DataFrame columns
    position_error = np.sqrt(
        (log_df['X (m)'] - log_df['ideal X (m)'])**2 +
        (log_df['Y (m)'] - log_df['ideal Y (m)'])**2 +
        (log_df['Z (m)'] - log_df['ideal Z (m)'])**2
    ).values

    # Magnitude of control acceleration using DataFrame columns
    control_accel_mag = np.sqrt(
        log_df['Control Accel (X)']**2 +
        log_df['Control Accel (Y)']**2 +
        log_df['Control Accel (Z)']**2
    ).values

    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10), sharex=True)

    # Plot 1: Position Error
    ax1.plot(log_df['Time (s)'], position_error, label="Position Error")
    ax1.axhline(y=policy_params.get('gamma', 0), color='r', linestyle='--', label='Deadband Radius ($\gamma$)')
    ax1.set_ylabel("Distance from Ideal Position (m)")
    ax1.set_title("Controller Performance")
    ax1.grid(True)
    ax1.legend()

    # Plot 2: Control Acceleration
    ax2.plot(log_df['Time (s)'], control_accel_mag, label="Control Acceleration Magnitude")
    ax2.set_xlabel("Time (s)")
    ax2.set_ylabel("Control Acceleration ($m/s^2$)")
    ax2.grid(True)
    ax2.legend()
    
    plt.tight_layout()
    plt.show()


def plot_acceleration_components(log_df: pd.DataFrame, title='Acceleration Components Over Time'):
    """
    Plots the components of the total and control accelerations.
    """
    fig, axes = plt.subplots(3, 1, figsize=(12, 10), sharex=True)
    
    times = log_df['Time (s)'].values
    
    # Plot X components
    axes[0].plot(times, log_df['Control Accel (X)'], label='Control Accel (X)', linestyle='--')
    axes[0].plot(times, log_df['Total Accel (X)'], label='Total Accel (X)')
    axes[0].set_ylabel('Accel (m/s²)')
    axes[0].set_title('X-Component')
    axes[0].grid(True)
    axes[0].legend()
    
    # Plot Y components
    axes[1].plot(times, log_df['Control Accel (Y)'], label='Control Accel (Y)', linestyle='--')
    axes[1].plot(times, log_df['Total Accel (Y)'], label='Total Accel (Y)')
    axes[1].set_ylabel('Accel (m/s²)')
    axes[1].set_title('Y-Component')
    axes[1].grid(True)
    axes[1].legend()

    # Plot Z components
    axes[2].plot(times, log_df['Control Accel (Z)'], label='Control Accel (Z)', linestyle='--')
    axes[2].plot(times, log_df['Total Accel (Z)'], label='Total Accel (Z)')
    axes[2].set_ylabel('Accel (m/s²)')
    axes[2].set_title('Z-Component')
    axes[2].grid(True)
    axes[2].legend()
    
    axes[-1].set_xlabel('Time (s)')
    fig.suptitle(title, fontsize=16)
    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.show()


def plot_position_error(log_df: Union[str, pd.DataFrame], policy_params: dict):
    """
    Plots the satellite's distance from the reference trajectory in a dedicated figure.
    
    Args:
        log_df (Union[str, pd.DataFrame]): A DataFrame containing the simulation log
                                            or a path to a CSV file.
        policy_params (dict): A dictionary containing controller parameters,
                              specifically the deadband radius 'gamma'.
    """
    if isinstance(log_df, str):
        log_df = pd.read_csv(log_df)

    # Calculate distance from ideal position using DataFrame columns
    position_error = np.sqrt(
        (log_df['X (m)'] - log_df['ideal X (m)'])**2 +
        (log_df['Y (m)'] - log_df['ideal Y (m)'])**2 +
        (log_df['Z (m)'] - log_df['ideal Z (m)'])**2
    ).values

    # Create the figure and plot
    fig, ax = plt.subplots(figsize=(12, 6))

    ax.plot(log_df['Time (s)'], position_error, label="Position Error")
    ax.axhline(y=policy_params.get('gamma', 0), color='r', linestyle='--', label='Deadband Radius ($\gamma$)')
    ax.set_xlabel("Time (s)")
    ax.set_ylabel("Distance from Ideal Position (m)")
    ax.set_title("Satellite Position Error Over Time")
    ax.grid(True)
    ax.legend()
    
    plt.tight_layout()
    plt.show()


def plot_control_acceleration(log_df: Union[str, pd.DataFrame]):
    """
    Plots the magnitude of the control acceleration over time in a dedicated figure.
    
    Args:
        log_df (Union[str, pd.DataFrame]): A DataFrame containing the simulation log
                                            or a path to a CSV file.
    """
    if isinstance(log_df, str):
        log_df = pd.read_csv(log_df)
    
    # Magnitude of control acceleration using DataFrame columns
    control_accel_mag = np.sqrt(
        log_df['Control Accel (X)']**2 +
        log_df['Control Accel (Y)']**2 +
        log_df['Control Accel (Z)']**2
    ).values

    # Create the figure and plot
    fig, ax = plt.subplots(figsize=(12, 6))

    ax.plot(log_df['Time (s)'], control_accel_mag, label="Control Acceleration Magnitude")
    ax.set_xlabel("Time (s)")
    ax.set_ylabel("Control Acceleration ($m/s^2$)")
    ax.set_title("Control Acceleration Magnitude Over Time")
    ax.grid(True)
    ax.legend()

    plt.tight_layout()
    plt.show()



# ... (plot_conservation_laws and plot_controller_performance remain unchanged) ...
def plot_conservation_laws(times: np.ndarray, states: np.ndarray, title: str = 'Verification: Conservation Laws'):
    # This function is unchanged
    r_mag = np.linalg.norm(states[:, :3], axis=1); v_mag = np.linalg.norm(states[:, 3:], axis=1)
    energy = v_mag**2 / 2 - const.MU_EARTH / r_mag
    r_vecs = states[:, :3]; v_vecs = states[:, 3:]
    h_mag = np.linalg.norm(np.cross(r_vecs, v_vecs), axis=1)
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), sharex=True)
    ax1.plot(times / 3600, (energy - energy[0]) / energy[0]); ax1.set_ylabel('Relative Change in Energy\n($\Delta\epsilon / \epsilon_0$)'); ax1.set_title(title); ax1.grid(True)
    ax2.plot(times / 3600, (h_mag - h_mag[0]) / h_mag[0]); ax2.set_ylabel('Relative Change in Ang. Momentum\n($\Delta h / h_0$)'); ax2.set_xlabel('Time (hours)'); ax2.grid(True)
    plt.tight_layout(); plt.show()

